# Elm Autocomplete

```elm
module Autocomplete exposing
  ( State, empty, reset
  , Msg, UpdateConfig, updateConfig, update
  , HtmlDetails, ViewConfig, viewConfig, view
  )


-- MODEL
-- hide type then provide api that allows user to make only the modifications you want to allow

-- no alias here so that impl of State is private
type State =
  State
    { key : Maybe String -- item selected with keyboard
    , mouse : Maybe String -- item selected with mouse
    }

-- functions supporting only ALLOWED modifications of State (prevents user from mucking with state on their own)
empty: State
empty =
  State { key = Nothing, mouse = Nothing }

reset : State -> State
reset (State { key, mouse }) =
  State { key = Nothing, mouse = Nothing }


-- UPDATE

type Msg
  = KeyChange String
  | WentTooLow
  | WentTooFar
  | MouseEnter String
  | MouseLeave String
  | MouseClick String

type UpdateConfig msg =
  UpdateConfig
    { onKeyDown : KeyCode -> Bool -- indicates which key used to select value
    , onChoose : String -> msg
    , onTooLow : Maybe msg -- Maybe => optional
    , onTooHigh : Maybe msg
    }

updateConfig -- allows UpdateConfig to be private and also allows for defaults to be used
  : { onKeyDown : KeyCode -> Bool
    , onChoose : String -> msg
    , onTooLow : Maybe msg
    , onTooHigh : Maybe msg
    }
    -> UpdateConfig msg
updateConfig { onKeyDown, onChoose, onTooLow, onTooHigh } =
  UpdateConfig
    { onKeyDown = onKeyDown
    , onChoose = onChoose
    , onTooLow = onTooLow
    , onTooHigh = onTooHigh
    }

-- msg generated by UpdateConfig are same msg that may be returned by update function. This allows user to handle their own messages instead of the components messages. This is more similar to HTML onClick etc. handlers
update : UpdateConfig msg -> Msg -> State -> (State, Maybe msg)
update (UpdateConfig config) msg (State state) = ...


-- VIEW

type alias HtmlDetails msg = -- allows for all details of li element to be customized, except tag name itself
  { attributes : List (Attribute msg)
  , children : List (Html msg)
  }

-- for data = List a
type ViewConfig a =
  ViewConfig
    { toId : a -> String -- converts data a to unique string id
    , ul : List (Attribute Never) -- allows user to style ul
    , li : Bool -> a -> HtmlDetails Never -- Bool = whether this item is selected. Never indicates this html doesn't emit messages (e.g. external messages). Instead, external messages are defined within updateConfig and returned by update.
    }

viewConfig
  : { toId : a -> String
    , ul : List (Attribute Never)
    , li: Bool -> a -> HtmlDetails Never
    }
    -> ViewConfig a
viewConfig { toId, ul, li } =
  ViewConfig
    { toId = toId
    , ul = ul
    , li = li
    }

view : ViewConfig a -> Int -> State -> List a -> Html Msg
  view (ViewConfig config) howManyToShow state data = ...

```


# Elm Sortable table

Table view config contains `toMsg: State -> msg`
Table view returns `Html msg` (note: msg same as toMsg function return)
clicking header changes table state to `State columnName isReversed` and calls toMsg with that new state.
`msg` then emitted by Parent view html (which includes the Table.view html)
Parent update then called sets new state
Parent view then called rendering table with new state
=> data sorted within table according to state and displayed

* emits a whole new state every time a header is clicked for sorting since state is so simple in this case
* no internal Msg in this case
* no explicit update function in this case (instead `onClick` function produces a new state and wraps it in msg using toMsg)
